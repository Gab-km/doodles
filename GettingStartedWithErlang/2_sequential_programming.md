# 2 順を追ってのプログラミング

## 2.1 Erlang のシェル

ほとんどの OS にはコマンドインタープリタかシェルがあり、Unix と Linux にはたくさん、Windows にはコマンドプロンプトがあります。Erlang には、ちょっとした Erlang のコードを直接書くことができて、何が起こるか(STDLIB マニュアルのページ [shell(3)](http://erlang.org/doc/man/shell.html)を参照してください)を確かめるためにそれらを評価(実行)することができる、専用のシェルがあります。

お使いの OS にあるシェル化コマンドインタープリタを立ち上げて、`erl` とタイプすることでErlang のシェルを(Linux か Unix で)開始させます。するとこのような感じのものが見られるでしょう。

```
% erl
Erlang R15B (erts-5.9.1) [source] [smp:8:8] [rq:8] [async-threads:0] [hipe] [kernel-poll:false]

Eshell V5.9.1  (abort with ^G)
1>
```

シェル上で "2 + 5." と打ち込み、エンター(キャリッジ・リターン)を入力してみましょう。終止符 "." とキャリッジ・リターンで終わることで、コードを入力し終わったよとシェルに伝えていることに気をつけましょう。

```
1> 2 + 5.
7
2>
```

ご覧のとおり、Erlang シェルは入力された行に番号を振り(1> 2> のように)、それから 2 + 5 が 7 であると正しく回答します。シェル上で入力を間違ってしまった場合、ほとんどのシェルのようにバックスペースキーで削除することができます。シェルにはさらに多くの編集用コマンドがあります(ERTS ユーザガイドにある ["tty - A command line interface"](http://erlang.org/doc/apps/erts/tty.html) を参照してください)。

(以下の例で、シェルから設定された多くの行番号が順番通りではないことに注意してください。これは、このチュートリアルがそれぞれのセッションで書かれ、コードがテストされたためです)

こちらは、より複雑な計算です:

```
2> (42 + 77) * 66 / 3.
2618.0
```

カッコの使用、乗算演算子 "*"、そして除算演算子 "/"、これらは普通の四則演算です([Expressions](http://erlang.org/doc/reference_manual/expressions.html) を参照してください)。

Erlang システムと Erlang シェルをシャットダウンするには Control-C を入力します。

次のように出力されます:

```
BREAK: (a)bort (c)ontinue (p)roc info (i)nfo (l)oaded
       (v)ersion (k)ill (D)b-tables (d)istribution
a
%
```

"a" を入力すると Erlang システムを離れます。

Erlang システムを終了するもう1つの方法は、`halt()`と入力することです:

```
3> halt().
%
```

## 2.2 モジュールと関数

シェルからだけでしかコードを実行できないであれば、プログラミング言語はあまり役に立ちません。そこで、ここに小さな Erlang プログラムがあります。適したテキストエディタを使って`tut.erl`という名前のファイルにそれを入力します。`tut.erl`というファイル名は重要であり、また`erl`を開始したのと同じディレクトリにあります。もしあなたのエディタが入力やコードを良い感じにフォーマットするのをより簡単にしてくれる Erlang モード(ツールユーザガイドにある [The Erlang mode for Emacs](http://erlang.org/doc/apps/tools/erlang_mode_chapter.html) を参照してください)があるならラッキーですが、無くても完璧に上手くやれます。こちらが入力するコードです:

```erl
-module(tut).
-export([double/1]).

double(X) ->
    2 * X.
```

この「プログラム」が数値を倍にするのを推測するのは大変じゃありません。最初の2行は後で見てみることとしましょう。さあこのプログラムをコンパイルしてみてください。Erlang シェルでいかに表示するようにやってみましょう:

```
3> c(tut).
{ok,tut}
```

`{ok,tut}`はコンパイルが成功したということです。もし "error" と言われたら、入力したテキストに何か間違いがあるということです。追加のエラーメッセージが何が悪かったのかを教えてくれるので、書いた内容を変更してもう一度プログラムをコンパイルしてみることができます。

では、プログラムを実行してみましょう。

```
4> tut:double(10).
20
```

期待したとおり、10の倍は20です。

それでは、最初に2行に戻ってみましょう。Erlang のプログラムはファイル内に書かれます。それぞれのファイルは Erlang *モジュール* を含みます。モジュールにあるコードの最初の行はモジュールの名前です(["Modules"](http://erlang.org/doc/reference_manual/modules.html) を参照してください):

```erl
-module(tut).
```

なので、このモジュールは *tut* と呼ばれます。行末の終止符 "." に注意してください。モジュールを保存するために使われるファイルは、拡張子の ".erl" を除いてモジュールと同じ名前でなければなりません。今回のケースでは、ファイル名は`tut.erl`です。別のモジュールにある関数を使う時は、`module_name:function_name(arguments)`という文法を使います。ですから以下は`tut`モジュールにある`double`関数を引数 "10" で呼び出しているということです。

```
4> tut:double(10).
```

2行目は`tut`モジュールが`double`という関数を持っており、それは1つの引数(私たちの例では`X`)を取るということです:

```erl
-export([double/1]).
```

2行目はこの関数が`tut`モジュールの外から呼ぶこともできるということも表しています。これについては、あとでさらに説明します。繰り返しになりますが、行末の"."に注意してくださいね。

さて、もっと複雑な例として、数の階乗です。例えば、4の階乗は 4 * 3 * 2 * 1 で、これは 24 と等しくなります。

以下のコードを`tut1.erl`という名前のファイルに入力してみましょう:

```erl
-module(tut1).
-export([fac/1]).

fac(1) ->
    1;
fac(N) ->
    N * fac(N - 1).
```

これはモジュールで`tut1`と呼ばれ、`fac`という名前の関数を有しており、この関数は1つの引数`N`を取ります。

最初の部分は、1の階乗は1だということを表しています:

```erl
fac(1) ->
    1;
```

(鋭意翻訳中)